# Сервис Сегментации Пользователей

## Содержание

- [Введение](#введение)
- [Начало работы](#начало-работы)
    - [Установка](#установка)
    - [Использование](#использование)
- [Эндпоинты](#эндпоинты)
    - [Создание Сегмента](#создание-сегмента)
    - [Удаление Сегмента](#удаление-сегмента)
    - [Изменение Сегментов Пользователя](#изменение-сегментов-пользователя)
    - [Получение Активных Сегментов Пользователя](#получение-активных-сегментов-пользователя)
    - [Получение Ссылки на CSV Отчет](#получение-ссылки-на-csv-отчет)
- [Заметки](#заметки)

## Введение
Этот проект представляет собой практическое задание, необходимое для отбора на стажировку в компанию Avito. 
В рамках этого задания требовалось разработать инструмент для эффективного управления сегментами пользователей. 
Этот инструмент позволяет категоризировать и настраивать взаимодействие с пользователями на основе разнообразных критериев. 
Кроме того, проект предполагает создание механизма для формирования отчетов об изменениях в сегментах пользователей.

Были выполнены все основные и дополнительные задания (кроме покрытия тестами), при написании проекта придерживался приемов
чистой архитектуры. Попутно написаны пакеты с возможностью повторного использования.

В проекте использованы следующие технологии:
- PostgreSQL (в качестве хранилища данных)
- Masterminds/squirrel (builder sql-запросов)
- golang-migrate/migrate (для миграций БД)
- pgx (драйвер для работы с PostgreSQL)
- Docker (для запуска сервиса)
- Swagger (для документации API)
- Echo (веб фреймворк)


## Начало работы

### Установка

Перед началом убедитесь, что у вас выполнены следующие предварительные требования:

- Docker (для контейниризации)
- Docker Compose

Для настройки сервиса выполните следующие шаги:

1. Склонируйте этот репозиторий.
2. Перейдите в каталог проекта.
3. При необходимости отредактируйте конфигурационные файлы (config/config.yaml и .env).
4. Выполните следующую команду для запуска сервиса:

   ```bash
   docker-compose up --build -d
   ```

После запуска сервиса, вы можете ознакомиться с документацией, посетив следующий адрес: 
[`http://localhost:8080/swagger/index.html`](http://localhost:8080/swagger/index.html). 
Обратите внимание, что для доступа к документации и аутентификации необходимо передавать API KEY в формате `Bearer <api_key>` в поле Authorization. По умолчанию, сервис использует порт 8080.

### Использование

Чтобы взаимодействовать с сервисом, вы можете использовать различные API-эндпоинты, как описано в разделе [Эндпоинты](#эндпоинты). 
Кроме того, предварительно заполненные конфигурационные файлы (config/config.yaml и .env) предоставляются для ускорения процесса тестирования. 
Если требуется внести изменения в настройки, не стесняйтесь редактировать эти файлы.

Для доступа к API используются API KEY, которыми можно управлять через командную строку с помощью следующих команд:

- Для создания нового API KEY:
  ```bash
  docker exec -it app ./apikey generate
  ```
- Для проверки существования API KEY:
  ```bash
  docker exec -it app ./apikey exist <token>
  ```

Для ознакомления с возможностями был создан файл [example.http](example.http). 
Выполняйте команды последовательно из этого файла. Хотя он не охватывает все возможные сценарии, 
предоставленные запросы помогут упростить проверку проекта.


## Эндпоинты

### Создание Сегмента

Эндпоинт для создания сегмента пользователей. Поддерживает дополнительную опцию `percentageUsers`, которая 
автоматически включит определенный процент пользователей в сегмент. Обратите внимание, что `"percentageUsers": 10000` соответствует 100%. 
В истории для автоматически добавленных пользователей будет указан тип события "auto_add".

#### Запрос для создания сегмента

```http request
POST /api/v1/segments/create
Content-Type: application/json
Authorization: Bearer <token>

{
  "slug": "AVITO_DISCOUNT_30"
}
```

#### Запрос для создания сегмента с использованием дополнительной опции

```http request
POST /api/v1/segments/create
Content-Type: application/json
Authorization: Bearer <token>

{
  "slug": "AVITO_DISCOUNT_30",
  "percentageUsers": 10000
}
```

#### Ответ

```json
{
  "slug": "AVITO_DISCOUNT_30"
}
```

### Удаление Сегмента

Эндпоинт для удаления сегмента. При удалении сегмента, из него выбывают все пользователи. 
В истории для удаленных пользователей будет указан тип события `delete_segment`.

#### Запрос для удаления сегмента

```http request
DELETE /api/v1/segments/delete
Content-Type: application/json
Authorization: Bearer <token>

{
  "slug": "AVITO_DISCOUNT_30"
}
```

#### Ответ

```
<Response body is empty>
```

### Изменение Сегментов Пользователя

Этот метод обеспечивает внесение и удаление сегментов пользователя. 
Если один из сегментов в разделе `segments_add` не существует, запрос завершится ошибкой. Это поведение не относится к разделу `segments_del`.
В истории, добавление сегмента помечается как "add", а удаление как "del".

Метод также поддерживает дополнительную опцию `ttl`, которая указывает через сколько минут будут удалены у пользователя сегменты 
из `"segments_add"`. Если необходимо внести пользователя в сегменты на неограниченное время, `"ttl"` передавать не нужно.

Запись истории учитывает неправильные операции и не фиксирует такие изменения. 
К примеру, если производится попытка удаления пользователя из сегмента, в котором он не числится.

#### Запрос для изменения сегментов

```http request
POST /api/v1/users/segments
Content-Type: application/json
Authorization: Bearer <token>

{
  "user_id": "<user_id>",
  "ttl": 10,
  "segments_add": [
    "AVITO_DISCOUNT_AUTO",
    "AVITO_PERFORMANCE_VAS"
  ],
    "segments_del": [
    "AVITO_OLD"
  ]
}
```

#### Ответ

```
<Response body is empty>
```

### Получение Активных Сегментов Пользователя

Этот метод позволяет получить список сегментов, в которых находится конкретный пользователь. 
Для этого необходимо выполнить GET запрос, передав ID пользователя в качестве аргумента URL.

#### Запрос для получения сегментов пользователя

```http request
GET /api/v1/users/active-segments?user_id=<user_id>
Content-Type: application/json
Authorization: Bearer <token>
```

#### Ответ

```json
{
  "user_id": "<user_id>",
  "segments": [
    "AVITO_DISCOUNT_AUTO",
    "AVITO_PERFORMANCE_VAS"
  ]
}
```

### Получение Ссылки на CSV Отчет

Этот метод предоставляет ссылку на CSV-отчет о пользователе за определенный месяц и год. 
Полученная ссылка всегда остается действительной, и отчет можно скачивать без использования API KEY.

#### Запрос для получения ссылки на отчет

```http request
POST /api/v1/history/report-link
Content-Type: application/json
Authorization: Bearer <token>

{
  "user_id": "<user_id>",
  "year": 2023,
  "month": 8
}
```

#### Ответ

```json
{
  "user_id": "b2c03a4c-4409-11ee-be56-0242ac120011",
  "report_link": "http://localhost:8080/reports/b2c03a4c-4409-11ee-be56-0242ac120011-2023-8-1693231794.csv"
}
```

#### Пример отчета по ссылке `report_link`

```csv
UserID,SegmentSlug,Type,CreatedAt
b2c03a4c-4409-11ee-be56-0242ac120011,AVITO_DISCOUNT_AUTO,add,2023-08-28 13:42:45.336724 +0000 UTC
b2c03a4c-4409-11ee-be56-0242ac120011,AVITO_PERFORMANCE_VAS,add,2023-08-28 13:58:17.369431 +0000 UTC
```

## Заметки

В ходе разработки были некоторые вопросы и размышления. Здесь описаны принятые решения.

### Обеспечение доступа к сервису

В задании не было четко определено, как будет реализовано ограничение доступа к сервису. 
В связи с этим было принято решение использовать ключи API для обеспечения безопасности эндпоинтов. 
Учитывая, что стандартная процедура регистрации могла быть не подходящей, был разработан интерфейс командной строки 
(CLI) для генерации этих ключей. Согласно задумке, эти ключи будут предоставляться команде, работающей над разработкой 
и поддержкой сервиса.

### Формат хранения user_id
Возникли определенные сложности с выбором формата для хранения user_id. Вероятно, в микросервисах 
Авито применяется формат UUID, однако для надежности я решил принять тип VARCHAR(40), который способен вместить как 
UUID (36 символов), так и другие пользовательские идентификаторы.

### Способ удаления сегмента

Учитывая неопределенность относительно ценности устаревших сегментов для аналитических целей, а также с 
учетом возможной нагрузки на сервис, было решено упростить процедуру удаления. Вместо внедрения дополнительных 
сложностей, таких как флаги активности с последующим групповым удалением, был выбран более простой подход. 
Реализовано каскадное удаление сегмента у всех пользователей при его удалении.

### Сводка в CSV отчете

В примере отчета по пользователям, предоставленном в задании, указаны идентификаторы двух пользователей. 
Однако в самом задании фокусируются на получении отчета по одному конкретному пользователю. 
Я принял решение реализовать метод получения отчета исключительно для одного пользователя, полагая, что это опечатка.

### Ссылке на отчет по пользователю

Была создана постоянная ссылка на отчет, при этом оригинальный отчет не удаляется. 
Это было сделано с учетом возможной необходимости доступа к отчету в исходном состоянии на будущее. 
Кроме того, было решено исключить аутентификацию по API KEY, чтобы обеспечить возможность свободного обмена данной ссылкой.

### Типы событий в отчете

С целью более подробного отражения истории изменений пользовательских сегментов было расширено разнообразие типов операций:

- `add` - операция добавления пользователя в сегмент с помощью запроса к API.
- `delete` - операция удаления пользователя из сегмента через запрос к API или по истечении установленного TTL.
- `auto_add` - автоматическое добавление пользователя в сегмент при создании сегмента с дополнительной опцией "percentageUsers".
- `delete_segment` - операция удаления пользователя из сегмента, связанная с удалением самого сегмента.